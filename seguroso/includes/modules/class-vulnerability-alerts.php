<?php

/*
 * Vulnerability Alerts from WPScan
 * 
 * Thanks to the plugin === WP Updates Notifier ===
 * https://github.com/l3rady/wp-updates-notifier
 */

class G2_Vulnerability_Alerts {

    static $remote;
    static $report;
    static public $id = 'g2-security';

    /**
     * G2_Vulnerability_Alerts constructor.
     */
    public function __construct() {
        $nextRun = get_option('g2_vulnerability_check');
        if (time() >= $nextRun) {            
            update_option('g2_vulnerability_check', time() + ( 12 * 60 * 60 ) + rand(60,600));
            add_action('init', array($this, 'notify_admin'), 20);
        }
        //add_action('init', array($this, 'notify_admin'), 20);
    }

    static public function get_vulnerabilities($data, $version) {
        $list = array();
        $key = key($data);
        foreach ($data[$key]->vulnerabilities as $item) {
            if (version_compare($version, $item->fixed_in, '<'))
                $list[] = $item;
        }

        return $list;
    }

    static public function list_vulnerabilities($type, $name = NULL) {
        $report = self::$report[$type];
        if (array_key_exists($name, $report))
            $report = $report[$name];
        if (!isset($report['vulnerabilities'])) {
            _e('Report not available', self::$id);

            return;
        }
        $list = array();
        foreach ($report['vulnerabilities'] as $item) {
            if ($type == 'plugins') {
                $slug = '';
                $slug = explode('/', $name);
                $slug = str_ireplace('.php', '', end($slug));
                $html = '<a href="' . esc_url('https://ezosc.com/g2-vulndb/?plugin=' . $slug) . '" target="_blank">';
            } else {
                $html = '<a href="' . esc_url('https://wpvulndb.com/vulnerabilities/' . $item->id) . '" target="_blank">';
            }
            $html .= esc_html($item->title) . ' - ';
            $html .= empty($item->fixed_in) ? __('Not fixed', self::$id) : sprintf(__('Fixed in version %s', self::$id), $item->fixed_in);
            $html .= '</a>';
            $list[] = $html;
        }
        echo empty($list) ? '- -' : join('<br>', $list);
    }

    static public function get_status($type, $name = NULL) {
        $report = self::$report[$type];
        if (array_key_exists($name, $report))
            $report = $report[$name];
        if (!isset($report['vulnerabilities']))
            return '&nbsp; <span class="dashicons dashicons-no-alt" style="color:gray"></span>';
        if (empty($report['vulnerabilities']))
            return '&nbsp; <span class="dashicons dashicons-yes" style="color:green"></span>';
        else
            return '&nbsp; <span class="dashicons dashicons-warning" style="color:Crimson"></span>';
    }

    // pull json data from WPVULNDB's API
    function get_data($text_domain) {
        $url = 'https://wpvulndb.com/api/v2/plugins/' . $text_domain;
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
        $data = curl_exec($ch);
        curl_close($ch);

        $dataArray = json_decode($data, true);
                
        return json_decode(json_encode($dataArray[$text_domain]));
    }

    public function notify_admin() {
        $plugins = get_plugins();
        $vuln_plugins = array();
        foreach ($plugins as $key => $plugin) {
            // if text domain isn't listed get the plugin folder name
            if (empty($plugin['TextDomain'])) {
                $folder_name = explode('/', $key);
                $plugin['TextDomain'] = $folder_name[0];
            }
            $plugin['is_known_vulnerable'] = 'false';
            $plugin_vuln = $this->get_data($plugin['TextDomain']);
            
            if (is_object($plugin_vuln)) {
                foreach ($plugin_vuln->vulnerabilities as $vulnerability) {
                    $plugin['vulnerabilities'][] = $vulnerability;
                    // if plugin fix is greater than current version, assume it could be vulnerable
                    if (version_compare($vulnerability->fixed_in, $plugin['Version']) > 0) {
                        $plugin['is_known_vulnerable'] = 'true';
                    }
                }
            }
            if (isset($plugin['is_known_vulnerable']) && $plugin['is_known_vulnerable'] == 'true') {
                $name = $plugin['Name'];
                $vuln_plugins[] = $plugin['Name'];
            }
            $plugin['file_path'] = $key;
            $plugins[$key] = $plugin;
        }
        // send email if vulnderabilities have been detected
        $config = get_option('g2Security');
        if (!empty($config['email']) && !empty($vuln_plugins)) {
            $plugin_url = get_admin_url() . 'admin.php?page=g2-security-dashboard';
            
            $message = G2_Email::get_header()
                    .'We have detected one or more of your plugins are vulnerable. (' . implode(', ', $vuln_plugins) . '). ' . "\n\n" 
                    . 'Please log into your website here: ' . $plugin_url 
                    . ' and update your plugins.' 
                    . G2_Email::get_footer();
            
            $email = trim($config['email']);
            wp_mail($email, G2_Email::get_subject('alert') . ' - Vulnerability Detected', $message);
        }
    }

    public static function get_vulnerability_alerts() {
        $cachedData = get_transient('g2_report');
        if ($cachedData == FALSE or $_REQUEST['action'] == 'g2_report_check_now') {
            if (!function_exists('get_plugins'))
                require_once ABSPATH . 'wp-admin/includes/plugin.php';
            $report = array();
            // WordPress
            $report['wordpress'] = array();
            $report['wordpress']['total'] = 0;
            $version = get_bloginfo('version');
            $response = wp_remote_get('https://wpvulndb.com/api/v2/wordpresses/' . str_replace('.', '', $version), G2_Vulnerability_Alerts::$remote);
            if (is_array($response)) {
                $result = (array) json_decode($response['body']);
                if (!empty($result)) {
                    $report['wordpress']['vulnerabilities'] = G2_Vulnerability_Alerts::get_vulnerabilities($result, $version);
                    $report['wordpress']['total'] = count($report['wordpress']['vulnerabilities']);
                }
            }
            // Plugins
            $report['plugins'] = array();
            $report['plugins']['total'] = 0;
            foreach (get_plugins() as $name => $details) {
                $parts = pathinfo($name);
                $response = wp_remote_get('https://wpvulndb.com/api/v2/plugins/' . $parts['dirname'], G2_Vulnerability_Alerts::$remote);
                if (is_array($response)) {
                    $result = (array) json_decode($response['body']);
                    if (!empty($result)) {
                        $report['plugins'][$name]['vulnerabilities'] = G2_Vulnerability_Alerts::get_vulnerabilities($result, $details['Version']);
                        $report['plugins']['total'] += count($report['plugins'][$name]['vulnerabilities']);
                    }
                }
            }
            // Themes
            $report['themes'] = array();
            $report['themes']['total'] = 0;
            foreach (wp_get_themes() as $name => $details) {
                $response = wp_remote_get('https://wpvulndb.com/api/v2/themes/' . $name, G2_Vulnerability_Alerts::$remote);
                if (is_array($response)) {
                    $result = (array) json_decode($response['body']);
                    if (!empty($result)) {
                        $report['themes'][$name]['vulnerabilities'] = G2_Vulnerability_Alerts::get_vulnerabilities($result, $details['Version']);
                        $report['themes']['total'] += count($report['themes'][$name]['vulnerabilities']);
                    }
                }
            }
            update_option('g2_report_last_check', time());
            set_transient('g2_report', $report, 12 * 60 * 60);
        } else {
            $report = $cachedData;
        }
        return $report;     
    }

}
